# 源码阅读

* 核心入口代码：
    ```cpp
    int main() {
        Application app;
        app.init();
        Logger::setLogLevel(LogLevel::TRACE);

            // add service 
            // 注册service中的init方法 （注册为一个coro 待wookloop中调用）
        app.newService<DBService>("DBService");
        app.newService<QueryService>("QueryService");

        // 触发wookloop
        return app.run();
    }
    ```

* 线程模型

    ```cpp
    int Application::run() {
        Singleton<LogThread>::instance().start();
        Singleton<WorkThread>::instance().start();
        Singleton<Net::SocketThread>::instance().start();
        Singleton<TimeThread>::instance().start();
        Singleton<TimeThread>::instance().join();
        Singleton<Net::SocketThread>::instance().join();
        Singleton<WorkThread>::instance().join();
        Singleton<LogThread>::instance().join();
        return 0;
    }
    ```

##### 线程类别分为：

* 日志线程
    
    异步写日志


* workthread线程 

    负责处理event loop中的消息，每个service都有自己的msg队列，不同线程上的workthread处理的service一定是不同的，保证service级别是并发安全的。 

* socket线程 

    1. workthread --> socketthread 

        Service的所有网络请求都是通过写入一个pipe传递给socketthread，Linux下在数据量不超过一个阈值的时候，对pipe的写入是原子的，框架里保证了这个原子写入成立。
    
    2. socketthread --> workthread 
            
        网络请求到来时，socketthread会把网络数据打包放入对应Service的pq中。 |
| timer线程 | 定时器时间到了，timer线程会往对应的Service的pq中push一个消息。 |


---

* workthread 的 eventloop : 

    ```cpp
    WorkThread::WorkThread() {
        int n = Singleton<Config>::instance().getInt("thread.workthread_count", 6);
        for (int i = 0; i < n; ++i) {
            m_threads.push_back(
                std::make_shared<Thread>(
                    work, std::string("workthread_") + std::to_string(i)));
        }
    }

    void WorkThread::work() {
        auto& G = Singleton<GlobalQueue>::instance();
        while(running) {
            // 从一级队列里面找到service ctx的队列
            // 然后再从ctx的对立里面拿到packle，让这个ctx去处理packle任务
            if (!G.empty()) {
                auto que = G.pop();          // 从一级队列里面拿到二级队列
                if (!que) {
                    continue;
                }
                que->startProcess();
                auto ctx = que->context();   // 获得service context 
                auto context = ctx.lock();   // 通过weak ptr找到service_context 
                if (!context) {
                    continue;
                }
                ServiceContext::setCurrentContext(context);
                context->doFork();   // what ? 
                int size = (int)que->size();
                for (int i = 0; i < size; ++i) {
                    Packle::sPtr packle = que->pop();
                    assert(packle);
                    context->dispatch(packle);   // what ? 
                }
                que->finishProcess(context->hasFork());
                ServiceContext::setCurrentContext(nullptr);
            }
        }
    }
    ```

* 异步设计：

    ```cpp
    class QueryService : public Service {
    public:
            // init 在newService阶段注册为一个coro
            // workloop中调用
        void init(Packle::sPtr packle) override {
            assert(context() == ServiceContext::currentContext());
            Packle::sPtr query = std::make_shared<Packle>((Packle::MsgID)MsgID::Query);
            LOG_INFO << "QueryService init begin call DBService ";
            
            // 发起异步调用，
            // 向msg queue插入一个task，然后把自己挂起
            call("DBService", query);
            
            // 协程唤醒后继续执行
            Packle::sPtr response = responsePackle();
            test::Response resp = response->deserialize<test::Response>();
            LOG_INFO << "name: " << resp.name() << " age: " << resp.age() << " email: " << resp.email(0);
        }
    };

    class DBService : public Service{
    public:
            // 注册msg的回调函数
        void init(Packle::sPtr packle) override {
            assert(context() == ServiceContext::currentContext());
            registerFunc((Packle::MsgID)MsgID::Query,
                std::bind(&DBService::query, this, std::placeholders::_1));
        }

            // 从workloop遍历任务队列，找到packle的类型，调用对应的回调函数
            // 再workloop中把query包装为一个coro，通过协程跳转到这里
        void query(Packle::sPtr packle) {
            Packle::sPtr response = std::make_shared<Packle>((Packle::MsgID)MsgID::Response);
            test::Response resp;
            resp.set_name("nagisa");
            resp.set_age(18);
            resp.add_email("xxx@xxx.com");
            response->serialize(resp);
            response->setSessionID(packle->sessionID());
            LOG_INFO << "recv query req and set rsp " << resp.ShortDebugString();
            
            // 设置返回值
            // 将结果写入到自己的service ctx的m_returnPackle
            // workloop会轮训每一个service ctx，调用ServiceContext::dispatch
            // 在dispatch中会把返回值设置到source的队列中
            // 这个时候对方service ctx会在work loop被轮训到，轮训到之后 唤醒协程 获取返回值 
            setReturnPackle(response);
        }
    };
    ```

---


* 类设计：

* Application类 

    作用：
        
        持有Service类的map 1对n 

        提供整个app的init/run/stop

    方法：
    
        Application::init() 
        
        Application::run()
        
        ServiceID newService() 
    

* service 类

    作用：

        持有service ctx指针  1对1 
        
        提供call接口/设置返回值接口
        
        提供timer接口
        
        提供msg注册msg proc接口
        
        提供设置ctx接口

* ServiceContext 

        作用：        
        一个service对应一个service context，Service类的核心方法都是再Service ctx中实现的
        
    
        方法：
        m_messageQueue  // 任务队列
        
        service name    // 名称
        
        m_returnPackle  // 返回值 
        
        createContext(name) // 通过名字创建ctx
        
        registerHandler(messageID, handler) // 注册msg的处理函数
        
        dispatch  // 事件循环
        
        call      // 核心方法
        
        setReturnPackle // 设置返回值
        
        getCoroutine    // 创建协程任务 

        
*  WorkThread 

        std::vectorThread::sPtr m_threads; 
    
        WorkThread::work()   // workloop 入口，在apprun的时候调用，每个工作线程都是一个workloop 


* Coroutine 协程类 

        resume()     // 协程重入
        
        yieldToSuspend()   // 协程挂起 | 非对称协程，实现main→co1→main→co2这样的跳转

* ServiceContextMgr类

        全局类辅助类，提供static接口，实现name到service ctx的注册/获取


---

- coro类

    提供协程任务创建，协程任务resume，协程yield等功能。协程的函数栈跳转是基于libco中抠出来的一段代码封装的。

    协程调度是非对称协程（从main→协程1→main→协程2），每次的切换都回从main切换到某个协程任务，然后这个任务执行完毕或者被挂起后，再切换会main，main在调度到另外一个协程。依次类推。

    简单说明协程类的接口使用和跳转的原理，写了一个例子在说明：

    coro类的核心逻辑： (test_coro1.cc中）

    ```cpp
    // 1. 创建一个协程任务，指定对应的协程函数coro_func
    // main函数中
    Packle::sPtr packle = std::make_shared<Packle>();
    Coroutine::sPtr task1 = CreateCoroutine(
        std::bind(coro_func, packle)
    );

    // 2. 协程被唤醒去执行，从main切换到协程
    // main函数中
    task->resume();

    // 3. resume中的实现，保存当前的函数栈，切换到task的函数栈去执行
    void Coroutine::resume(Coroutine::sPtr coroutine) {
        // ... 
        coctx_swap(&t_mainCoroutine->m_ctx, &coroutine->m_ctx);
    }

    // 4. 协程入口函数 （当一个协程第一次被调度的时候，从这里开始执行）
    void Coroutine::coFuncEntry(Coroutine* self) {
        // ... 
        self->m_func();    // 执行用户指定的函数
        yieldToStopped();
    }

    // 5. 进入用户指定的协程任务函数
    void coro_func(Packle::sPtr packle) {
        LOG_INFO << "coro_func first enter"; sleep(1);

        Coroutine::yieldToSuspend();    // 6. 执行到这里协程被挂起
        LOG_INFO << "coro_func second enter"; sleep(1);
        
        // ...
        return;
    }

    // 6. 在协程中执行到这里被挂起，保存当前的函数栈，切换会main
    void Coroutine::yieldToSuspend() {
            // ...
        coctx_swap(&cor->m_ctx, &t_mainCoroutine->m_ctx);
    }

    // 7. 再次回到main函数
    // 如果在main函数中再次调用 resume，那么上一个协程会被再次唤醒，从上次挂起的地方继续执行
    task->resume();
    ```

    这里使用了动态内存分配的方式去保存被切出来的函数的栈，默认是1MB。这里有一个潜在的问题就是如果函数的栈超过了这个空间，会造成写越界。并且这里没有添加保存措施。可以使用在stack前后各申请一个4k页的内存，做为barry，使用mprotect修改为不可写。这样当发生写越界的时候，会立刻abort，更容易排查出问题。

    ```cpp
    // 动态内存作为函数的栈
    Coroutine::Coroutine(CoroutineFunc func, uint32_t stackSize)
        : m_func(func)
        , m_state(CoroutineState::INIT) {
        assert(t_mainCoroutine);
        m_id = t_coroutineID++;
        m_stackSize = stackSize ? stackSize :
            Singleton<Config>::instance().get<uint32_t>(
                "coroutine.stack_size", 1024 * 1024);
        m_stack = new char[m_stackSize];       // 动态内存
        m_stackTop = m_stack + m_stackSize;
        initContext();
    }
    ```

- service call service

    这个feature我觉得是最核心的一部分设计。在整个框架的设计中每个serivce都被视作一个执行最小单元。同时，利用协程实现的一个非常简洁的异步调用模型。

    1. 每个service有一个自己的任务队列，当某个service call 另外一个service的时候，被call的service的任务队列中会插入一个任务。然后自己被挂起。
    2. 在event loop中被遍历每个service的任务队列，找到里面的任务，执行对应被call service中的调用。代码中把任务和数据封装为了packle。
    3. 被调用的服务同样也可以把返回数据写入到packle中，然后插入到source service的队列中。
    4. 在event loop中，遍历到source service 的队列中，取出packle，根据返回值判断是否这个packle是一个返回值，如果是的话，那么唤醒上次的协程继续执行。

- net

    epoll封装了一个net接口，提供handle read/write的接口。

- timer

    timer的实现是采用了时间轮的机制来实现的。常见的timer实现机制是时间轮或者最小堆。时间轮也是linux中timer的实现机制，简单的说就是有几个不同精度的时间转盘，这样可以用较少的空间来表达更长的时间范围。 在添加timer任务时候，通过延后的时间计算出对应在时间轮上面的位置，然后插入到时间轮上面。timer被触发是通过eventloop循环中，不停的往前推timer，触发对应的timer任务。

- log

    log模块比较简单了，前台和后台两个线程，前台写入到buffer中，后台线程周期性的写入到终端。可以优化的地方是，程序coredump的时候，存在关键日志打印不出来的可能性。

----

- 一些好的设计：
    1. call机制
    2. std::any
    3. 单例模板类
    4. 提供了service类中异步sleep函数（背后是timer的实现）

-----

- Todo : 
    1. m_forkingQueue 这个命名太怪了，其实就是等待执行的任务队列；m_suspendingPool是被调度执行后，挂起来的队列任务；ServiceContext::doFork() 这个命名也可以改一改

    2. ServiceContext::getSession() 这个名字太诡异了，是create更好。

    3. 大量使用assert，assert在debug中和release的行为不一致。在release模式下，assert会do nothing。一般的项目会对assert封装一下，即使在release模型下，也会打印出log和backtrace，帮助定位问题。

    4. log在coredump的时候，无法打印出关键日志。可以注册信号的处理函数，在退出之前flush一下log的buffer，把日志打出来。

    ```cpp
    inline void sigHandler(int32_t sig) {
        LOG_INFO << "recv signal: " << sig;
        Singleton<LogThread>::instance().forceFlush();
        exit(1);
    }

    void installSigHandle() {
        signal(SIGABRT, sigHandler);
        signal(SIGSEGV, sigHandler);
        signal(SIGKILL, sigHandler);
    }
    ```